module Day16

using DataStructures

function parse_input(raw::AbstractString)
    lines = split(strip(raw), '\n')
    valve_count = length(lines)
    # Order valves by decreasing flow rate so that states of working valves can
    # easily fit into a fixed-size bitmask. However, still put valve AA first
    # so that it is easier to index as the initial valve (by assuming for the
    # sake of comparison that it has the largest flowrate).
    valvedata = sort(
        parse_line.(lines),
        lt=(t1, t2)->(t1[1] != "AA" && (t2[1] == "AA" || <(t1[2], t2[2]))),
        rev=true
    )
    valvenames = Vector{String}(undef, valve_count)
    valveindices = Dict{String, Int}()
    flowrates = Vector{Int}(undef, valve_count)
    for (i, (name, rate, _)) in enumerate(valvedata)
        flowrates[i] = rate
        valveindices[name] = i
    end
    neighbors = Vector{Vector{Int}}(undef, valve_count)
    for (i, (_, _, valve_neighbors)) in enumerate(valvedata)
        neighbors[i] = [valveindices[n] for n in valve_neighbors]
    end
    return flowrates, neighbors
end

Input = Tuple{
    <:AbstractVector{<:Integer},
    <:AbstractVector{<:AbstractVector{<:Integer}}
}

struct State
    valveidx::Int
    valvestates::UInt64
    timeleft::Int
    playeridx::Int
end

function solve_part1(input::Input)
    (flowrates, neighbors) = input
    @assert sum(1 for rate in flowrates if rate != 0) <= 64
    lut = Dict{State, Int}()
    state = get_initial_state()
    return total_pressure!(lut, state, flowrates, neighbors)
end

function solve_part2(input::Input)
    (flowrates, neighbors) = input
    @assert sum(1 for rate in flowrates if rate != 0) <= 64
    lut = Dict{State, Int}()
    state = get_initial_state(playeridx=2, multiplay=true)
    return total_pressure!(lut, state, flowrates, neighbors)
end

function parse_line(line::AbstractString)
    regex = Regex(string(
        raw"^Valve ([A-Z]+) has flow rate=(\d+); ",
        raw"tunnels? leads? to valves? ([A-Z, ]+)$"
    ))
    captures = match(regex, line).captures
    valvename = captures[1]
    flowrate = parse(Int, captures[2])
    neighbors = split(captures[3], ", ")
    return valvename, flowrate, neighbors
end

function get_initial_state(;
    playeridx::Integer=1,
    multiplay::Bool=false,
    valvestates::UInt64=zero(UInt64),
)
    if multiplay
        return State(1, valvestates, 26, playeridx)
    else
        @assert playeridx == 1
        return State(1, valvestates, 30, 1)
    end
end

# Use a LUT, so previously evaluated states do not get re-evaluated in the
# recursion (dynamic programming).
#
# Part 2 observations:
# - It is clearly suboptimal if the elephant and me go for the same working
# valves.
# - The elephant and me could therefore agree beforehand to go for disjoint
# sets of working valves.
# - For all possible moves I have made, each resulting in a different history
# of opening valves, we examine all possible series of actions by the
# elephant.
# - It is therefore not needed to consider our actions simultaneously, we could
# consider it sequentially for the sake of optimization: we simply join the
# elephant decision tree at the end of each branch of my decision tree.
function total_pressure!(
    lut::Dict{State, Int},
    state::State,
    flowrates::AbstractVector{<:Integer},
    neighbors::AbstractVector{<:AbstractVector{<:Integer}}
)
    i = state.valveidx
    valvestates = state.valvestates
    timeleft = state.timeleft
    playeridx = state.playeridx

    if timeleft == 0
        if playeridx > 1
            return total_pressure!(
                lut,
                get_initial_state(
                    playeridx=playeridx-1,
                    multiplay=true,
                    valvestates=valvestates,
                ),
                flowrates,
                neighbors,
            )
        else
            return 0
        end
    end

    if haskey(lut, state)
        return lut[state]
    end

    # Get (i - 1)-th bit (1 for open)
    is_open = valvestates & (1 << (i - 1)) != 0
    flowrate = flowrates[i];

    result = 0

    # Calculate total pressure when opening the valve (if it is working)
    if !is_open && flowrate > 0
        # Set (i - 1)-th bit to 1 (open)
        new_valvestates = valvestates | (1 << (i - 1))
        result = max(
            result,
            flowrate * (timeleft - 1) + total_pressure!(
                lut,
                State(i, new_valvestates, timeleft - 1, playeridx),
                flowrates,
                neighbors,
            )
        )
    end
    # Calculate total pressure when not touching the valve but moving on to
    # the neighboring valves
    for j in neighbors[i]
        result = max(
            result,
            total_pressure!(
                lut,
                State(j, valvestates, timeleft - 1, playeridx),
                flowrates,
                neighbors,
            )
        )
    end

    lut[state] = result
    return result
end

end # module
